<!DOCTYPE html>
<html lang="cn">
<head prefix="og: http://ogp.me/ns#"><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>Cinder</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://g-cinder.github.io/Memoranda/project_specs/ui_performance.html">
  <!-- Alternative links -->
  
    
      <link rel="alternative" hreflang="cn" href="https://g-cinder.github.io/Memoranda/project_specs/ui_performance.html">
    
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/Memoranda/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/Memoranda/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/Memoranda/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/Memoranda/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/Memoranda/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/Memoranda/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/Memoranda/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/Memoranda/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/Memoranda/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/Memoranda/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/Memoranda/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/Memoranda/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/Memoranda/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/Memoranda/icon/mstile-144x144.png">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  <link rel="stylesheet" href="/Memoranda/css/navy.css">
  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <!-- Open Graph -->
  <meta name="description" content="UI制作规范与渲染优化 材料与思路由引擎技术部 周升腾 支持。  UI规范与优化，其目标是提升游戏运行时的FPS，手段是尽量减少Draw Call数量（降低GPU压力）和限制Rebuild、Rebatch次数（降低CPU压力）。  优化时得益于图集的合理性，除了提升FPS，也能少量降低内存占用。 Draw Call是为了降低GPU压力，但在过程中有时Draw Call优化过多，反而增加CPU等的负">
<meta property="og:type" content="website">
<meta property="og:title" content="Cinder">
<meta property="og:url" content="https://g-cinder.github.io/Memoranda/project_specs/ui_performance.html">
<meta property="og:site_name" content="Cinder">
<meta property="og:description" content="UI制作规范与渲染优化 材料与思路由引擎技术部 周升腾 支持。  UI规范与优化，其目标是提升游戏运行时的FPS，手段是尽量减少Draw Call数量（降低GPU压力）和限制Rebuild、Rebatch次数（降低CPU压力）。  优化时得益于图集的合理性，除了提升FPS，也能少量降低内存占用。 Draw Call是为了降低GPU压力，但在过程中有时Draw Call优化过多，反而增加CPU等的负">
<meta property="og:locale" content="cn">
<meta property="og:image" content="https://g-cinder.github.io/Memoranda/project_specs/Images.png">
<meta property="og:updated_time" content="2021-03-04T04:19:42.332Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cinder">
<meta name="twitter:description" content="UI制作规范与渲染优化 材料与思路由引擎技术部 周升腾 支持。  UI规范与优化，其目标是提升游戏运行时的FPS，手段是尽量减少Draw Call数量（降低GPU压力）和限制Rebuild、Rebatch次数（降低CPU压力）。  优化时得益于图集的合理性，除了提升FPS，也能少量降低内存占用。 Draw Call是为了降低GPU压力，但在过程中有时Draw Call优化过多，反而增加CPU等的负">
<meta name="twitter:image" content="https://g-cinder.github.io/Memoranda/project_specs/Images.png">
</head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/Memoranda/" id="logo">Cinder</a>
    </h1>
    <nav id="main-nav">
      <a href="/Memoranda/cinder_framework" class="main-nav-link">通用框架</a><a href="/Memoranda/code_specs/" class="main-nav-link">代码规范</a><a href="/Memoranda/project_specs/" class="main-nav-link">项目规范</a><a href="/Memoranda/staff_management/" class="main-nav-link">人员管理</a><a href="/Memoranda/technology_share/" class="main-nav-link">技术分享</a>
    </nav>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name"></h1>
                <a href="https://github.com/hexojs/site/edit/master/source/project_specs/ui_performance.md" class="article-edit-link" title="改进本文"><i class="fa fa-pencil"></i></a>
              </header>
              <div class="article-content" itemprop="articleBody">
                <h1 id="UI制作规范与渲染优化" class="article-heading"><a href="#UI制作规范与渲染优化" class="headerlink" title="UI制作规范与渲染优化"></a>UI制作规范与渲染优化<a class="article-anchor" href="#UI制作规范与渲染优化" aria-hidden="true"></a></h1><blockquote>
<p><strong>材料与思路由引擎技术部 周升腾 支持。</strong></p>
</blockquote>
<p>UI规范与优化，其目标是<strong>提升游戏运行时的FPS</strong>，手段是尽量<strong>减少Draw Call数量（降低GPU压力）</strong>和<strong>限制Rebuild、Rebatch次数（降低CPU压力）</strong>。</p>
<ul>
<li>优化时得益于图集的合理性，除了提升FPS，也能少量降低内存占用。</li>
<li>Draw Call是为了降低GPU压力，但在过程中有时Draw Call优化过多，反而增加CPU等的负担，得不偿失。因此要依据实际情况合理优化。</li>
</ul>
<h2 id="Draw-Call优化" class="article-heading"><a href="#Draw-Call优化" class="headerlink" title="Draw Call优化"></a>Draw Call优化<a class="article-anchor" href="#Draw-Call优化" aria-hidden="true"></a></h2><h3 id="概述" class="article-heading"><a href="#概述" class="headerlink" title="概述"></a>概述<a class="article-anchor" href="#概述" aria-hidden="true"></a></h3><p>减少Draw Call就是要有更多的图片渲染可以自动和批。<br>而决定UI元素网格能否自动和批的三个关键分别是：<strong>Texture</strong>、<strong>Material</strong>和<strong>UI Depth</strong>。</p>
<ul>
<li>Texture：项目中，该属性即为加载的图集。如果两张图来自于同一图集则代表这一条件通过。</li>
<li>Material：该属性代表UI所用的材质，若相同则此条件满足。</li>
<li>UI Depth：该属性表示三张Image所在的UI深度，若相同则表示满足。</li>
</ul>
<p>上面三个条件同时满足时，则两个对象可以和批，Draw Call数-1。</p>
<blockquote>
<p>除了上面三个大条件，仍然有两个小点需要注意</p>
<ol>
<li>UI元素Position Z值的设置，如果Z！=0，UI不处于Canvas平面内，则UI无法Batch。</li>
<li>UI元素Rotation X值、Y值的设置，如果导致UI元素不处于Canvas平面内，则UI无法Batch。</li>
</ol>
</blockquote>
<p><strong>Material</strong>很好理解，就是材质，也一般就用默认的不去做改动；<strong>Texture</strong>则需要在打图集的时候尽量优化其策略，最主要两点就是：1. 充分利用空间。2. 尽量保证需要同时加载的图片来自同一图集。<br>那么<strong>UI Depth</strong>呢？这里用一个例子来解释。</p>
<h3 id="UI-Depth计算过程" class="article-heading"><a href="#UI-Depth计算过程" class="headerlink" title="UI Depth计算过程"></a>UI Depth计算过程<a class="article-anchor" href="#UI-Depth计算过程" aria-hidden="true"></a></h3><p>这里通过3个Image UI来说明计算过程，它们互相重叠，关系如下：</p>
<p><img src="Images.png" alt="Images"></p>
<p>(1) 如果redImage，greenImage，blueImage的材质与纹理均相同，符合Batch条件，UI Depth处于同一层。</p>
<table>
<thead>
<tr>
<th>UI Name</th>
<th>Material</th>
<th>Texture</th>
<th>UI Depth</th>
</tr>
</thead>
<tbody>
<tr>
<td>redImage</td>
<td>A</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>greenImage</td>
<td>A</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>blueImage</td>
<td>A</td>
<td>A</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>(2) 如果redImage与blueImage使用相同材质纹理，UI Depth处于不同层。</p>
<table>
<thead>
<tr>
<th>UI Name</th>
<th>Material</th>
<th>Texture</th>
<th>UI Depth</th>
</tr>
</thead>
<tbody>
<tr>
<td>redImage</td>
<td>A</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>greenImage</td>
<td>B</td>
<td>B</td>
<td>1</td>
</tr>
<tr>
<td>blueImage</td>
<td>A</td>
<td>A</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>(3) 如果redImage，greenImage，blueImage使用不同材质纹理，UI Depth处于不同层。</p>
<table>
<thead>
<tr>
<th>UI Name</th>
<th>Material</th>
<th>Texture</th>
<th>UI Depth</th>
</tr>
</thead>
<tbody>
<tr>
<td>redImage</td>
<td>A</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>greenImage</td>
<td>B</td>
<td>B</td>
<td>1</td>
</tr>
<tr>
<td>blueImage</td>
<td>C</td>
<td>C</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>(4) 如果redImage，greenImage使用相同材质纹理，blueImage与前两个UI处于不同层。</p>
<table>
<thead>
<tr>
<th>UI Name</th>
<th>Material</th>
<th>Texture</th>
<th>UI Depth</th>
</tr>
</thead>
<tbody>
<tr>
<td>redImage</td>
<td>A</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>greenImage</td>
<td>A</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>blueImage</td>
<td>B</td>
<td>B</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="总结" class="article-heading"><a href="#总结" class="headerlink" title="总结"></a>总结<a class="article-anchor" href="#总结" aria-hidden="true"></a></h3><p>有了上面的例子，应该就能很好的理解UI Depth的计算过程。那么优化思路也就明确了，就是不能让不同材质和贴图的UI元素打断自动和批。<br>总结下来就是：<strong>保持材质统一性，尽量让同一图集的UI元素放在同一父节点下</strong>。</p>
<h2 id="Rebuild与Rebatch限制" class="article-heading"><a href="#Rebuild与Rebatch限制" class="headerlink" title="Rebuild与Rebatch限制"></a>Rebuild与Rebatch限制<a class="article-anchor" href="#Rebuild与Rebatch限制" aria-hidden="true"></a></h2><blockquote>
<p><strong>渲染是GPU的工作，而在它之前CPU端的Prepare工作也同样需要关注与优化。</strong></p>
</blockquote>
<p>Rebuild与Rebatch是什么？<br>在CPU端，一个Canvas负责把它上面的UI元素合并成批次，生成合适的渲染命令，发送给Unity的图像系统，当Canvas需要被重绘时，则被标记为Dirty，触发Rebuild，Rebatch。</p>
<ul>
<li>Layout Rebuild主要是布局组件对Dirty元素重新布局，来控制UI元素的位置与大小。</li>
<li>Graphic Rebuild主要是UI元素的网格，材质，纹理等发生了变化，由此需要重建UI元素网格。</li>
<li>Rebatch主要是重新计算并合并UI元素网格，合批生成Drwa Call发送给Unity的渲染管线。</li>
</ul>
<h3 id="Layout-Rebuild" class="article-heading"><a href="#Layout-Rebuild" class="headerlink" title="Layout Rebuild"></a>Layout Rebuild<a class="article-anchor" href="#Layout-Rebuild" aria-hidden="true"></a></h3><p>UGUI中涉及到Layout的组件主要有ContentSizeFitter、VerticalLayoutGroup、HorizontalLayoutGroup、 AspectRatioFitter、GridLayoutGroup、LayoutElement。</p>
<p>这些组件在GetChildSizes()方法中拿到每个元素的区域，并在LayoutUtility. GetLayoutProperty()方法中，把每个实现ILayoutElement接口的对象的信息取出来，进行自动布局。</p>
<p>它有这些性能开销：</p>
<ul>
<li>每个使Layout变脏的UI元素都会至少执行一次GetComponents()调用，它会在布局元素父对象上寻找有效的Layout组件，这是一个向上For循环的遍历过程，直到找到有效组件或到达根部分，然后SetLayoutDirty()，进行Rebuild。</li>
<li>要重新计算包含一个或多个Layout组件合适的位置(大小)，会将这些UI 按照Hierarchy中的深度，对Dirty的Layout UI元素排序，层次结构中高的项排在前面，然后按照排序结果进行计算。</li>
</ul>
<p>总的来说：它们会带来额外的性能损耗，但仍然可以与其带来的开发效率提升相权衡</p>
<h3 id="Graphic-Rebuild" class="article-heading"><a href="#Graphic-Rebuild" class="headerlink" title="Graphic Rebuild"></a>Graphic Rebuild<a class="article-anchor" href="#Graphic-Rebuild" aria-hidden="true"></a></h3><p>UGUI被标记为dirty，除了SetLayoutDirty()外，还有SetVerticesDirty()、SetMaterialDirty()，而且如果调整了UI元素在Hierarchy中的父节点，还会调用OnTransformParentChanged() ，通过SetAllDirty()方法将该UI加入“Rebuild队列”。</p>
<ul>
<li>如果UI顶点数据被标记为dirty，就会导致网格重建(例如UI的RectTransform改变了大小)。</li>
<li>如果材质数据被标记为dirty，附加的Canvas Render的材质将被更新(例如UI的材质或者纹理被更改)。</li>
</ul>
<blockquote>
<p>通常来说，Graphic Rebuild比Layout Rebuild更耗费性能。</p>
</blockquote>
<p>在优化Rebuild时，我们可以通过函数反射监听m_LayoutRebuildQueue与m_GraphicRebuildQueue队列，来确定哪些操作会导致UI的Rebuild。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.Type type = typeof(CanvasUpdateRegistry);</span><br><span class="line">FieldInfo field = type.GetField(&quot;m_LayoutRebuildQueue&quot;, BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">m_LayoutRebuildQueue = (IList&lt;ICanvasElement&gt;)field.GetValue(CanvasUpdateRegistry.instance);</span><br><span class="line">field = type.GetField(&quot;m_GraphicRebuildQueue&quot;, BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">m_GraphicRebuildQueue = (IList&lt;ICanvasElement&gt;)field.GetValue(CanvasUpdateRegistry.instance);</span><br></pre></td></tr></table></figure>
<h3 id="Rebatch" class="article-heading"><a href="#Rebatch" class="headerlink" title="Rebatch"></a>Rebatch<a class="article-anchor" href="#Rebatch" aria-hidden="true"></a></h3><ul>
<li>Batch是指Canvas合并UI元素的网格，然后生成Draw Call发送给Unity的渲染管线的过程，<strong>Batch的结果会被缓存，直到UI重新标记为Dirty</strong>。</li>
<li>动态的更新UI元素，如网格变化、UI层级变化等都会使其变为Dirty，Canvas使用的网格是从CanvasRenderer上获取，计算Batch需要按照网格的深度，是否遮挡，是否共享材质等方面进行排序。</li>
<li>此操作是多线程的，因此不同的CPU结构，执行的性能也不同。</li>
</ul>
<h3 id="总结-1" class="article-heading"><a href="#总结-1" class="headerlink" title="总结"></a>总结<a class="article-anchor" href="#总结-1" aria-hidden="true"></a></h3><ol>
<li>UGUI的Layout组件会造成额外的性能开销，可以考虑编写自定义代码来进行布局。</li>
<li>Rebuild需要反射监听队列来跟踪优化。</li>
<li>动静分离能很好限制Rebuild和Rebatch次数。</li>
</ol>
<h2 id="其他细则" class="article-heading"><a href="#其他细则" class="headerlink" title="其他细则"></a>其他细则<a class="article-anchor" href="#其他细则" aria-hidden="true"></a></h2><ol>
<li>Raw Image不会与Image和批，但更为轻量，通常用于背景图这类大图。</li>
<li>不要使用Outline，它将顶点拷贝了四份。</li>
<li>不要使用Image Tiled，它生成了大量网格。</li>
<li>不要使用Mask 和 RectMask2D，它们不仅会影响合批，还会导致其他额外的性能开销。</li>
<li>结合实际情况，选择使用SetActive，设置Culling Layer或Destroy。</li>
</ol>

              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2021-03-04T04:19:42.332Z" itemprop="dateModified">上次更新：2021-03-04</time>
                <a href="ui_flow.html" class="article-footer-prev" title="UI制作流程"><i class="fa fa-chevron-left"></i><span>上一页</span></a><a href="configdata_tool.html" class="article-footer-next" title="打表工具与Protobuf代码生成工具使用说明"><span>下一页</span><i class="fa fa-chevron-right"></i></a>
              </footer>
            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UI制作规范与渲染优化"><span class="toc-text">UI制作规范与渲染优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Draw-Call优化"><span class="toc-text">Draw Call优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UI-Depth计算过程"><span class="toc-text">UI Depth计算过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rebuild与Rebatch限制"><span class="toc-text">Rebuild与Rebatch限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-Rebuild"><span class="toc-text">Layout Rebuild</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graphic-Rebuild"><span class="toc-text">Graphic Rebuild</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rebatch"><span class="toc-text">Rebatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他细则"><span class="toc-text">其他细则</span></a></li></ol></li></ol>
              <a href="#" id="article-toc-top">回到顶部</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <div class="sidebar-item"><strong class="sidebar-title">目录</strong><div class="sidebar-item"><a href="index.html" class="sidebar-link">概述</a></div><div class="sidebar-item"><a href="local_server_guide.html" class="sidebar-link">本地服务器搭建指南</a></div><div class="sidebar-item"><a href="ui_flow.html" class="sidebar-link">UI制作流程</a></div><div class="sidebar-item"><a href="ui_performance.html" class="sidebar-link current">UGUI优化策略</a></div><div class="sidebar-item"><a href="configdata_tool.html" class="sidebar-link">打表工具与Protobuf代码生成工具使用说明</a></div><div class="sidebar-item"><a href="git_flow.html" class="sidebar-link">使用Git管理代码必读</a></div><div class="sidebar-item"><a href="git_rule.html" class="sidebar-link">Git开发规则</a></div><div class="sidebar-item"><a href="configuration.html" class="sidebar-link">配置项规则</a></div></div>
  </div>
</aside>
    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2021 <a href="https://github.com/muguangyi/seek/graphs/contributors" target="_blank">Cinder</a><br>
      Documentation licensed under MIT.
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/Memoranda/cinder_framework" class="mobile-nav-link">通用框架</a><a href="/Memoranda/code_specs/" class="mobile-nav-link">代码规范</a><a href="/Memoranda/project_specs/" class="mobile-nav-link">项目规范</a><a href="/Memoranda/staff_management/" class="mobile-nav-link">人员管理</a><a href="/Memoranda/technology_share/" class="mobile-nav-link">技术分享</a>
    </ul>
    
      <div class="sidebar-item"><strong class="mobile-nav-title">目录</strong><div class="sidebar-item"><a href="index.html" class="mobile-nav-link">概述</a></div><div class="sidebar-item"><a href="local_server_guide.html" class="mobile-nav-link">本地服务器搭建指南</a></div><div class="sidebar-item"><a href="ui_flow.html" class="mobile-nav-link">UI制作流程</a></div><div class="sidebar-item"><a href="ui_performance.html" class="mobile-nav-link current">UGUI优化策略</a></div><div class="sidebar-item"><a href="configdata_tool.html" class="mobile-nav-link">打表工具与Protobuf代码生成工具使用说明</a></div><div class="sidebar-item"><a href="git_flow.html" class="mobile-nav-link">使用Git管理代码必读</a></div><div class="sidebar-item"><a href="git_rule.html" class="mobile-nav-link">Git开发规则</a></div><div class="sidebar-item"><a href="configuration.html" class="mobile-nav-link">配置项规则</a></div></div>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>Chinese</span></span>
    <select id="mobile-lang-select" data-canonical="">
      
        <option value="cn" selected>Chinese</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- Cookie -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.0/js.cookie.min.js"></script>
<!-- build:js build/js/main.js -->
<script src="/Memoranda/js/lang_select.js"></script>
<script src="/Memoranda/js/toc.js"></script>
<script src="/Memoranda/js/mobile_nav.js"></script>
<!-- endbuild -->

</body>
</html>